package parsing
import (
    "fmt"
)

type NodeParams struct {
	nodeId  int
	ancList []int
	params  TypedParams
}

type WorkflowExecutionState struct {
	workflow     Workflow
	index        WorkflowIndex
	allocatedCmd map[int]bool
	// node id -> runID of last async ancestor (-1 if none) -> value
	inputs             map[int]map[int]NodeParams
	// node id -> run ID -> output list
	outputs      map[int]map[int]NodeParams
	currentMaxId map[int]int

	// Node ID -> run ID of last async node
	unconsumedInputs map[int]map[int]struct{}

    // Node ID -> output ID of node -> input run ID that for run that 
    // generated the specified set of outputs.
	outputToInputRunId map[int]map[int]int

    inputToOutputRunId map[int]map[int][]int

    // Node ID -> input run ID of last async ancestor -> 
    // output run ID that has yet to be completed.
    remainingRuns   map[int]map[int]map[int]struct{}
}

func NewWorkflowExecutionState(
	workflow Workflow, index WorkflowIndex,
) WorkflowExecutionState {
	var state WorkflowExecutionState
	state.workflow = workflow
	state.index = index
	state.allocatedCmd = make(map[int]bool)
	state.inputs = make(map[int]map[int]NodeParams)
	state.outputs = make(map[int]map[int]NodeParams)
	state.currentMaxId = make(map[int]int)
	state.unconsumedInputs = make(map[int]map[int]struct{})
	state.outputToInputRunId = make(map[int]map[int]int)
    state.inputToOutputRunId = map[int]map[int][]int{}
    state.remainingRuns = make(map[int]map[int]map[int]struct{})

	for nodeId := range workflow.Nodes {
		state.inputs[nodeId] = make(map[int]NodeParams)
		state.outputs[nodeId] = make(map[int]NodeParams)
		state.unconsumedInputs[nodeId] = make(map[int]struct{})
		state.outputToInputRunId[nodeId] = make(map[int]int)
        state.inputToOutputRunId[nodeId] = make(map[int][]int)
        state.remainingRuns[nodeId] = make(map[int]map[int]struct{})
	}

	return state
}

func (state *WorkflowExecutionState) TriggerSuccessors(
	inputs NodeParams,
	outputs []TypedParams,
) (map[int][]NodeParams, error) {
	if err := state.addCmdResults(inputs, outputs); err != nil {
		return nil, err
	}

	return state.getEligibleSuccessors(inputs.nodeId)
}

func (state *WorkflowExecutionState) GetInitialNodeParams() (
    map[int]NodeParams, error,
) {
    startNodeIds := state.index.getStartNodes()
    outParams := make(map[int]NodeParams)
    for _, startNodeId := range startNodeIds {
        startNode, startNodeExists := state.workflow.Nodes[startNodeId]
        if ! startNodeExists {
            return nil, fmt.Errorf(
                "index error, could not find node %d listed as start node", 
                startNodeId,
            )
        }

        tp, err := parseTypedParams(startNode)
        if err != nil {
            return nil, fmt.Errorf(
                "error parsing node %d params: %s", startNodeId, err,
            )
        }

        outParams[startNodeId] = NodeParams{
            nodeId: startNodeId,
            ancList: []int{},
            params: tp,
        }

    }

    for nodeId := range state.workflow.Nodes {
        if len(state.index.asyncAncestors[nodeId]) == 0 {
            state.remainingRuns[nodeId][-1] = make(map[int]struct{})
            state.remainingRuns[nodeId][-1][-1] = struct{}{}
        }
    }

    return outParams, nil
}

func (state *WorkflowExecutionState) IsComplete() (bool, error) {
    // There are two things to consider here.
    // The first is whether all nodes that are not descended from async
    // nodes have run exactly once.
    // The second is whether each node that is descended from an async node
    // has run exactly once for each output generated by its most recent async
    // ancestor. (This is evaluated by asyncBlockComplete).
    // If either of these conditions is unmet, the workflow is not complete.
    for nodeId, node := range state.workflow.Nodes {
        if len(state.outputs[nodeId]) == 0 {
            return false, nil
        }


        nodeAsyncAncs, asyncAncsExist := state.index.asyncAncestors[nodeId]
        if !asyncAncsExist {
            return false, fmt.Errorf(
                "no async ancestor list for node %d", nodeId,
            )
        }

        isRootAsyncNode := node.Async && len(nodeAsyncAncs) == 0
        if isRootAsyncNode {
            // -1 is will be the single run ID for a node which has no async
            // ancestors.
            blockIsComplete, err := state.asyncBlockComplete(nodeId, -1) 
            if err != nil {
                return false, fmt.Errorf(
                    "error evaluating completeness of async block at node %d: %s",
                    nodeId, err,
                )
            }

            if !blockIsComplete {
                return false, nil
            }
        }
    }

    return true, nil
}

func (state *WorkflowExecutionState) consumeAncestorLists(
	nodeId int,
) ([][]int, error) {
	node, nodeExists := state.workflow.Nodes[nodeId]
	if !nodeExists {
		return nil, fmt.Errorf(
			"node %d does not exist",
			nodeId,
		)
	}

	asyncAncestors := state.index.asyncAncestors[nodeId]
	if len(asyncAncestors) == 0 {
		// A node runs once for every run of its topologically last
		// async ancestor. If it does not have any async ancestors,
		// it runs once, so it cannot be run again.
		if state.allocatedCmd[nodeId] {
			return [][]int{}, nil
		}

		if node.BarrierFor != nil {
			blockComplete, _ := state.asyncBlockComplete(*node.BarrierFor, -1)
			if !blockComplete {
				return [][]int{}, nil
			}
		}

		// Return a single empty ancestor list corresponding to the
		// one run of this not-run node.
		state.allocatedCmd[nodeId] = true
		return [][]int{{}}, nil
	}

	lastAsyncAnc := asyncAncestors[len(asyncAncestors)-1]
	_, outputsExist := state.outputs[lastAsyncAnc]
	if !outputsExist {
		return nil, fmt.Errorf(
			"node %d does not exist or has no outputs yet",
			lastAsyncAnc,
		)
	}

	unconsumedSet, unconsumedSetExists := state.unconsumedInputs[nodeId]
	if !unconsumedSetExists || unconsumedSet == nil {
		return nil, fmt.Errorf(
			"node %d has no or nil unconsumed set",
			lastAsyncAnc,
		)
	}

	unconsumed := make([][]int, 0)
	for asyncAncPredRunId := range unconsumedSet {
		if node.BarrierFor != nil {
			blockComplete, _ := state.asyncBlockComplete(
				*node.BarrierFor, asyncAncPredRunId,
			)
			if !blockComplete {
				continue
			}
		}

		asyncAncOutputs, asyncAncOutputsExist := state.outputs[lastAsyncAnc][asyncAncPredRunId]
		if !asyncAncOutputsExist {
			return nil, fmt.Errorf(
				"node %d has unconsumed array pointing to non-existent outputs",
				lastAsyncAnc,
			)
		}

		unconsumed = append(unconsumed, asyncAncOutputs.ancList)
		delete(state.unconsumedInputs[nodeId], asyncAncPredRunId)
	}

	if len(unconsumed) > 0 {
		state.allocatedCmd[nodeId] = true
	}

	return unconsumed, nil
}

func (state *WorkflowExecutionState) getLinkParam(
    link WorkflowLink,
    dstNode WorkflowNode,
    nodeId int,
    predRunId map[int]int,
) (any, WorkflowArgType, string, error) {
	srcNode := link.SourceNodeId
	srcChan := link.SourceChannel
	sinkChan := link.SinkChannel
	srcRunId, srcIsPred := predRunId[srcNode]
	inputRunId := state.outputToInputRunId[srcNode][srcRunId]
	if dstNode.BarrierFor != nil && *dstNode.BarrierFor == srcNode {
		inputRunId = srcRunId
	}

	if !srcIsPred {
		return nil, WorkflowArgType{}, "", fmt.Errorf(
			"bad index: %d not listed as pred of %d",
			srcNode, nodeId,
		)
	}

	srcArgType, srcArgTypeExists :=
		state.workflow.Nodes[srcNode].ArgTypes[srcChan]
	if !srcArgTypeExists {
		return nil, WorkflowArgType{}, "", fmt.Errorf(
			"bad argtype: node %d has no parameter %s",
			srcNode, srcChan,
		)
	}

	sinkArgType, sinkArgTypeExists :=
		state.workflow.Nodes[nodeId].ArgTypes[sinkChan]
	if !sinkArgTypeExists {
		return nil, WorkflowArgType{}, "", fmt.Errorf(
			"bad argtype: node %d has no parameter %s",
			nodeId, sinkChan,
		)
	}

	srcOutputParams := state.outputs[srcNode][srcRunId]
	srcPval, srcPvalExists := srcOutputParams.params.lookupParam(
		srcChan, srcArgType,
	)

	if !srcPvalExists {
		srcInput, paramsExist := state.inputs[srcNode][inputRunId]
		if !paramsExist {
		    return nil, WorkflowArgType{}, "", fmt.Errorf(
                "invalid run ID %d for node %d", inputRunId, srcNode,
            )
		}

		srcInputParams := srcInput.params
		srcPval, srcPvalExists = srcInputParams.lookupParam(
			srcChan, srcArgType,
		)

		if !srcPvalExists {
		    return nil, WorkflowArgType{}, "", fmt.Errorf(
				"param %s not found in node %d inputs or outputs",
				srcChan, srcNode,
			)
		}
	}

    return srcPval, sinkArgType, sinkChan, nil
}

func (state *WorkflowExecutionState) getPredRunIds(
    nodeId int, ancList []int,
) (map[int]int, error) {
	// If node's pred shares an async ancestor with it, you should use only
	// the version of this pred's outputs that were descended from this async
	// ancestor.
	// Get LCP between predecessor and node's ancList.
	predRunId := make(map[int]int)
	for _, pred := range state.index.preds[nodeId] {
		var err error
		lastSharedAsyncAncestorId, err := state.index.lastSharedAsyncAncestor(
			pred, nodeId,
		)

		if err != nil {
			return nil, fmt.Errorf(
				"could not find last shared async ancestor of %d and %d: %s",
				pred, nodeId, err,
			)
		}

		predRunId[pred], err = state.index.getAncListValue(
			nodeId, lastSharedAsyncAncestorId, ancList,
		)

		if err != nil {
			return nil, fmt.Errorf(
				"error looking up val of %d in ancestor list of %d: %s",
				lastSharedAsyncAncestorId, nodeId, err,
			)
		}
	}

    return predRunId, nil
}

func getInputRunId(ancList []int) int {
    if len(ancList) == 0 {
        return -1
    }
    return ancList[len(ancList)-1]
}


func (state *WorkflowExecutionState) addNodeRun(
    inputRunId int, inputNode WorkflowNode, 
    inputParams, outputParams NodeParams,
) {
    srcNodeId := inputParams.nodeId
    dstNodeId := outputParams.nodeId
    lastAsyncAncestorId := -1

    if len(inputParams.ancList) > 0 {
        lastAsyncAncestorId = inputParams.ancList[len(inputParams.ancList)-1]
    }
    state.inputs[srcNodeId][lastAsyncAncestorId] = inputParams

    if inputNode.Async {
	    runId := state.currentMaxId[dstNodeId]
	    outputParams.ancList = append(
	    	outputParams.ancList,
	    	state.currentMaxId[dstNodeId],
	    )
	    state.currentMaxId[dstNodeId] += 1
	    state.outputs[srcNodeId][runId] = outputParams
	    for _, desc := range state.index.asyncDescendants[srcNodeId] {
	    	if state.unconsumedInputs[desc] == nil {
	    		state.unconsumedInputs[desc] = make(map[int]struct{})
	    	}
	    	state.unconsumedInputs[desc][runId] = struct{}{}
            if state.remainingRuns[desc][inputRunId] == nil {
                state.remainingRuns[desc][inputRunId] = make(map[int]struct{})
            }
            state.remainingRuns[desc][inputRunId][runId] = struct{}{}
	    }

        state.outputToInputRunId[srcNodeId][runId] = inputRunId
        state.inputToOutputRunId[srcNodeId][inputRunId] = append(
            state.inputToOutputRunId[srcNodeId][inputRunId], runId,
        )
    } else {
		state.outputs[srcNodeId][inputRunId] = outputParams
        state.outputToInputRunId[srcNodeId][inputRunId] = inputRunId
        state.inputToOutputRunId[srcNodeId][inputRunId] = append(
            state.inputToOutputRunId[srcNodeId][inputRunId], inputRunId,
        )
    }
}

func (state *WorkflowExecutionState) markNodeRunComplete(
    nodeId int, ancList []int,
) error {
    inputIdOfNode := -1
    if len(ancList) > 0 {
        inputIdOfNode = ancList[len(ancList)-1]
    }

    inputIdOfLastAsyncAnc := -1
    if len(ancList) > 1 {
        inputIdOfLastAsyncAnc = ancList[len(ancList)-2]
    }

    if state.remainingRuns[nodeId][inputIdOfLastAsyncAnc] == nil {
        return fmt.Errorf(
            "remainingRuns var missing node %d, runId %d",
            nodeId, inputIdOfLastAsyncAnc,
        )
    }

    delete(state.remainingRuns[nodeId][inputIdOfLastAsyncAnc], inputIdOfNode)
    return nil
}

func (state *WorkflowExecutionState) formInputs(
	nodeId int, ancList []int,
) (NodeParams, error) {
	node, nodeExists := state.workflow.Nodes[nodeId]
	if !nodeExists {
		return NodeParams{}, fmt.Errorf("non-existent node ID %d", nodeId)
	}

	ret := NodeParams{
		nodeId:  nodeId,
		ancList: ancList,
	}
    ret.params = copyTypedParams(state.index.baseParams[nodeId])

    predRunIds, err := state.getPredRunIds(nodeId, ancList)
    if err != nil {
        return NodeParams{}, err
    }


	for _, link := range state.index.inLinks[nodeId] {
        srcPval, sinkArgType, sinkChan, err := state.getLinkParam(
            link, node, nodeId, predRunIds,
        )

        if err != nil {
            return NodeParams{}, fmt.Errorf(
                "error forming input for node %d: %s",
                nodeId, err,
            )
        }

        err = ret.params.addParam(srcPval, sinkChan, sinkArgType)
		if  err != nil {
            return NodeParams{}, err
        }
	}

	return ret, nil
}

func (state *WorkflowExecutionState) addCmdResults(
	inputs NodeParams,
	outputs []TypedParams,
) error {
	node, nodeExists := state.workflow.Nodes[inputs.nodeId]
	if !nodeExists {
		return fmt.Errorf("node %d of inputs does not exist", inputs.nodeId)
	}

	if len(outputs) > 1 && !node.Async {
		return fmt.Errorf("multiple outputs given for non-async node")
	}

	inputAncList := inputs.ancList
	if len(inputAncList) != len(state.index.asyncAncestors[inputs.nodeId]) {
		return fmt.Errorf("inputs have invalid ancestor list")
	}

	inputRunId := getInputRunId(inputAncList)
	//outputRunIds := make([]int, 0, len(outputs))
	for _, output := range outputs {
		var outputParams NodeParams
		outputParams.nodeId = inputs.nodeId
		outputParams.params = output
		outputParams.ancList = make([]int, len(inputAncList))
		copy(outputParams.ancList, inputAncList)

        state.addNodeRun(inputRunId, node, inputs, outputParams)
	}

    if err := state.markNodeRunComplete(inputs.nodeId, inputAncList); err != nil {
        return fmt.Errorf(
            "error marking node %d complete: %s", inputs.nodeId, err,
        )
    }
	return nil
}

// NodeID is async node. Run ID is the run ID of its input set,
// i.e. the run ID of the async ancestor of nodeId.
// TODO: Refactor this so to have a version which computes over
// all run IDs for a node.
func (state *WorkflowExecutionState) asyncBlockComplete(
	nodeId int, runId int,
) (bool, error) {
	node, nodeExists := state.workflow.Nodes[nodeId]
	if !nodeExists {
		return false, fmt.Errorf("non-existent node %d", nodeId)
	}
	if !node.Async {
		return false, fmt.Errorf("node %d is not async", nodeId)
	}

	for _, descId := range state.index.asyncDescendants[nodeId] {
        if len(state.remainingRuns[descId][runId]) > 0 {
            return false, nil
        }

        descNode := state.workflow.Nodes[descId]
        if descNode.Async {
            for _, descRunId := range state.inputToOutputRunId[nodeId][runId] {
                descComplete, err := state.asyncBlockComplete(descId, descRunId) 
                if err != nil {
                    return false, err
                }
                if ! descComplete {
                    return false, nil
                }
            }
        }
	}

	return true, nil
}

func (state *WorkflowExecutionState) getEligibleSuccessors(
	nodeId int,
) (map[int][]NodeParams, error) {
	// ID -> ancestor list
	ret := make(map[int][]NodeParams)
	for _, succ := range state.index.succs[nodeId] {
		succCanRun := true
		for _, predOfSucc := range state.index.preds[succ] {
			// Could we maybe filter this based on runId? I.e. Completion of
			// node ID with ancestor list will only trigger a successor if
			// other successors of pred have completed an iteration with same
			// ID of last async ancestor as nodeId?
			if len(state.outputs[predOfSucc]) == 0 {
				succCanRun = false
				break
			}
		}

		if succCanRun {
			newAncestorLists, err := state.consumeAncestorLists(succ)
			if err != nil {
				return nil, fmt.Errorf(
					"error generating ancestor lists: %s", err,
				)
			}

			for _, ancList := range newAncestorLists {
				params, err := state.formInputs(succ, ancList)
				if err != nil {
					return nil, fmt.Errorf(
						"error forming inputs for node %d with ancestor list %v: %s",
						succ, ancList, err,
					)
				}
				ret[succ] = append(ret[succ], params)
			}
		}
	}

	return ret, nil
}
