package parsing

import (
	"fmt"
	"strings"
)

type NodeParams struct {
	NodeId  int
	NodeDef WorkflowNode
	AncList []int
	Params  TypedParams
}

type WorkflowExecutionState struct {
	Workflow     Workflow
	Index        WorkflowIndex
	AllocatedCmd map[int]bool
	// node id -> runID of last async ancestor (-1 if none) -> value
	Inputs map[int]map[int]NodeParams
	// node id -> run ID -> output list
	Outputs         map[int]map[int]NodeParams
	CurrentMaxRunId map[int]int

	// Node ID -> run ID of last async node
	UnconsumedInputs map[int]map[int]struct{}

	// Node ID -> output ID of node -> input run ID that for run that
	// generated the specified set of outputs.
	OutputToInputRunId map[int]map[int]int

	InputToOutputRunId map[int]map[int][]int

	// Node ID -> input run ID of last async ancestor ->
	// output run ID that has yet to be completed.
	RemainingRuns map[int]map[int]map[int]struct{}
}

func NewWorkflowExecutionState(
	workflow Workflow, index WorkflowIndex,
) WorkflowExecutionState {
	var state WorkflowExecutionState
	state.Workflow = workflow
	state.Index = index
	state.AllocatedCmd = make(map[int]bool)
	state.Inputs = make(map[int]map[int]NodeParams)
	state.Outputs = make(map[int]map[int]NodeParams)
	state.CurrentMaxRunId = make(map[int]int)
	state.UnconsumedInputs = make(map[int]map[int]struct{})
	state.OutputToInputRunId = make(map[int]map[int]int)
	state.InputToOutputRunId = map[int]map[int][]int{}
	state.RemainingRuns = make(map[int]map[int]map[int]struct{})

	for nodeId := range workflow.Nodes {
		state.Inputs[nodeId] = make(map[int]NodeParams)
		state.Outputs[nodeId] = make(map[int]NodeParams)
		state.UnconsumedInputs[nodeId] = make(map[int]struct{})
		state.OutputToInputRunId[nodeId] = make(map[int]int)
		state.InputToOutputRunId[nodeId] = make(map[int][]int)
		state.RemainingRuns[nodeId] = make(map[int]map[int]struct{})
	}

	return state
}

func (state *WorkflowExecutionState) GetResourceReqs(nodeId int) ResourceVector {
	return state.Workflow.Nodes[nodeId].ResourceReqs
}

func (state *WorkflowExecutionState) getSuccParams(
	inputs NodeParams,
	outputs []TypedParams,
) (map[int][]NodeParams, error) {
	if err := state.addCmdResults(inputs, outputs); err != nil {
		return nil, err
	}

	return state.getEligibleSuccessors(inputs.NodeId)
}

func (state *WorkflowExecutionState) getInitialNodeParams() (
	map[int][]NodeParams, error,
) {
	startNodeIds := state.Index.getStartNodes()
	outParams := make(map[int][]NodeParams)
	for _, startNodeId := range startNodeIds {
		startNode, startNodeExists := state.Workflow.Nodes[startNodeId]
		if !startNodeExists {
			return nil, fmt.Errorf(
				"index error, could not find node %d listed as start node",
				startNodeId,
			)
		}

		baseProps := state.Workflow.NodeBaseProps[startNodeId]
		tp, err := parseTypedParams(startNode, baseProps)
		if err != nil {
			return nil, fmt.Errorf(
				"error parsing node %d params: %s", startNodeId, err,
			)
		}

		outParams[startNodeId] = []NodeParams{{
			NodeId:  startNodeId,
			AncList: []int{},
			Params:  tp,
			NodeDef: startNode,
		}}
	}

	for nodeId := range state.Workflow.Nodes {
		if len(state.Index.AsyncAncestors[nodeId]) == 0 {
			state.RemainingRuns[nodeId][-1] = make(map[int]struct{})
			state.RemainingRuns[nodeId][-1][-1] = struct{}{}
		}
	}

	return outParams, nil
}

func (state *WorkflowExecutionState) IsComplete() (bool, error) {
	// There are two things to consider here.
	// The first is whether all nodes that are not descended from async
	// nodes have run exactly once.
	// The second is whether each node that is descended from an async node
	// has run exactly once for each output generated by its most recent async
	// ancestor. (This is evaluated by asyncBlockComplete).
	// If either of these conditions is unmet, the workflow is not complete.
	for nodeId, node := range state.Workflow.Nodes {
		if len(state.Outputs[nodeId]) == 0 {
			return false, nil
		}

		nodeAsyncAncs, asyncAncsExist := state.Index.AsyncAncestors[nodeId]
		if !asyncAncsExist {
			return false, fmt.Errorf(
				"no async ancestor list for node %d", nodeId,
			)
		}

		isRootAsyncNode := node.Async && len(nodeAsyncAncs) == 0
		if isRootAsyncNode {
			// -1 is will be the single run ID for a node which has no async
			// ancestors.
			blockIsComplete, err := state.asyncBlockComplete(nodeId, -1)
			if err != nil {
				return false, fmt.Errorf(
					"error evaluating completeness of async block at node %d: %s",
					nodeId, err,
				)
			}

			if !blockIsComplete {
				return false, nil
			}
		}
	}

	return true, nil
}

func (state *WorkflowExecutionState) consumeAncestorLists(
	nodeId int,
) ([][]int, error) {
	node, nodeExists := state.Workflow.Nodes[nodeId]
	if !nodeExists {
		return nil, fmt.Errorf(
			"node %d does not exist",
			nodeId,
		)
	}

	asyncAncestors := state.Index.AsyncAncestors[nodeId]
	if len(asyncAncestors) == 0 {
		// A node runs once for every run of its topologically last
		// async ancestor. If it does not have any async ancestors,
		// it runs once, so it cannot be run again.
		if state.AllocatedCmd[nodeId] {
			return [][]int{}, nil
		}

		if node.BarrierFor != nil {
			blockComplete, _ := state.asyncBlockComplete(*node.BarrierFor, -1)
			if !blockComplete {
				return [][]int{}, nil
			}
		}

		// Return a single empty ancestor list corresponding to the
		// one run of this not-run node.
		state.AllocatedCmd[nodeId] = true
		return [][]int{{}}, nil
	}

	lastAsyncAnc := asyncAncestors[len(asyncAncestors)-1]
	_, outputsExist := state.Outputs[lastAsyncAnc]
	if !outputsExist {
		return nil, fmt.Errorf(
			"node %d does not exist or has no outputs yet",
			lastAsyncAnc,
		)
	}

	unconsumedSet, unconsumedSetExists := state.UnconsumedInputs[nodeId]
	if !unconsumedSetExists || unconsumedSet == nil {
		return nil, fmt.Errorf(
			"node %d has no or nil unconsumed set",
			lastAsyncAnc,
		)
	}

	unconsumed := make([][]int, 0)
	for asyncAncPredRunId := range unconsumedSet {
		if node.BarrierFor != nil {
			blockComplete, _ := state.asyncBlockComplete(
				*node.BarrierFor, asyncAncPredRunId,
			)
			if !blockComplete {
				continue
			}
		}

		asyncAncOutputs, asyncAncOutputsExist := state.Outputs[lastAsyncAnc][asyncAncPredRunId]
		if !asyncAncOutputsExist {
			return nil, fmt.Errorf(
				"node %d has unconsumed array pointing to non-existent outputs",
				lastAsyncAnc,
			)
		}

		unconsumed = append(unconsumed, asyncAncOutputs.AncList)
		delete(state.UnconsumedInputs[nodeId], asyncAncPredRunId)
	}

	if len(unconsumed) > 0 {
		state.AllocatedCmd[nodeId] = true
	}

	return unconsumed, nil
}

func correctArgType(pValRaw any, srcArgType, sinkArgType WorkflowArgType) (any, error) {
	srcIsList := strings.HasSuffix(srcArgType.ArgType, "list")
	sinkIsList := strings.HasSuffix(sinkArgType.ArgType, "list")
	srcBaseType := strings.Split(srcArgType.ArgType, " ")[0]
	sinkBaseType := strings.Split(sinkArgType.ArgType, " ")[0]

	bothStringTypes := argTypeIsStr(srcBaseType) && argTypeIsStr(sinkBaseType)
	if !bothStringTypes && srcBaseType != sinkBaseType {
		return nil, fmt.Errorf(
			"invalid types %s and %s",
			srcArgType.ArgType, sinkArgType.ArgType,
		)
	}

	if srcIsList && !sinkIsList {
		switch v := pValRaw.(type) {
		case []any:
			{
				return (pValRaw.([]any))[0], nil
			}
		case []string:
			{
				return (pValRaw.([]string))[0], nil
			}
		case []int:
			{
				return (pValRaw.([]int))[0], nil
			}
		case []float64:
			{
				return (pValRaw.([]float64))[0], nil
			}
		default:
			{
				return nil, fmt.Errorf("unrecognized type %v", v)
			}
		}
	}

	if !srcIsList && sinkIsList {
		return []any{pValRaw}, nil
	}
	return pValRaw, nil
}

func (state *WorkflowExecutionState) getLinkParam(
	link WorkflowLink,
	dstNode WorkflowNode,
	nodeId int,
	predRunId map[int]int,
) (any, WorkflowArgType, string, error) {
	srcNode := link.SourceNodeId
	srcChan := link.SourceChannel
	sinkChan := link.SinkChannel
	srcRunId, srcIsPred := predRunId[srcNode]
	inputRunId := state.OutputToInputRunId[srcNode][srcRunId]
	if dstNode.BarrierFor != nil && *dstNode.BarrierFor == srcNode {
		inputRunId = srcRunId
	}

	if !srcIsPred {
		return nil, WorkflowArgType{}, "", fmt.Errorf(
			"bad index: %d not listed as pred of %d",
			srcNode, nodeId,
		)
	}

	srcArgType, srcArgTypeExists :=
		state.Workflow.Nodes[srcNode].ArgTypes[srcChan]
	if !srcArgTypeExists {
		return nil, WorkflowArgType{}, "", fmt.Errorf(
			"bad argtype: node %d has no parameter %s",
			srcNode, srcChan,
		)
	}

	sinkArgType, sinkArgTypeExists :=
		state.Workflow.Nodes[nodeId].ArgTypes[sinkChan]
	if !sinkArgTypeExists {
		return nil, WorkflowArgType{}, "", fmt.Errorf(
			"bad argtype: node %d has no parameter %s",
			nodeId, sinkChan,
		)
	}

	srcOutputParams := state.Outputs[srcNode][srcRunId]
	srcPval, srcPvalExists := srcOutputParams.Params.LookupParam(
		srcChan, srcArgType,
	)

	if !srcPvalExists {
		srcInput, paramsExist := state.Inputs[srcNode][inputRunId]
		if !paramsExist {
			return nil, WorkflowArgType{}, "", fmt.Errorf(
				"invalid run ID %d for node %d", inputRunId, srcNode,
			)
		}

		srcInputParams := srcInput.Params
		srcPval, srcPvalExists = srcInputParams.LookupParam(
			srcChan, srcArgType,
		)

		if !srcPvalExists {
			return nil, WorkflowArgType{}, "", fmt.Errorf(
				"param %s not found in node %d inputs or outputs",
				srcChan, srcNode,
			)
		}
	}

	correctedSrcPval, err := correctArgType(srcPval, srcArgType, sinkArgType)
	if err != nil {
		return nil, WorkflowArgType{}, "", fmt.Errorf(
			"error converting param %s of node %d: %s", srcChan, srcNode, err,
		)
	}

	return correctedSrcPval, sinkArgType, sinkChan, nil
}

func (state *WorkflowExecutionState) getPredRunIds(
	nodeId int, ancList []int,
) (map[int]int, error) {
	// If node's pred shares an async ancestor with it, you should use only
	// the version of this pred's outputs that were descended from this async
	// ancestor.
	// Get LCP between predecessor and node's ancList.
	predRunId := make(map[int]int)
	for _, pred := range state.Index.Preds[nodeId] {
		var err error
		lastSharedAsyncAncestorId, err := state.Index.lastSharedAsyncAncestor(
			pred, nodeId,
		)

		if err != nil {
			return nil, fmt.Errorf(
				"could not find last shared async ancestor of %d and %d: %s",
				pred, nodeId, err,
			)
		}

		predRunId[pred], err = state.Index.getAncListValue(
			nodeId, lastSharedAsyncAncestorId, ancList,
		)

		if err != nil {
			return nil, fmt.Errorf(
				"error looking up val of %d in ancestor list of %d: %s",
				lastSharedAsyncAncestorId, nodeId, err,
			)
		}
	}

	return predRunId, nil
}

func getInputRunId(ancList []int) int {
	if len(ancList) == 0 {
		return -1
	}
	return ancList[len(ancList)-1]
}

func (state *WorkflowExecutionState) addNodeRun(
	inputRunId int, inputNode WorkflowNode,
	inputParams, outputParams NodeParams,
) {
	srcNodeId := inputParams.NodeId
	dstNodeId := outputParams.NodeId
	lastAsyncAncestorId := -1

	if len(inputParams.AncList) > 0 {
		lastAsyncAncestorId = inputParams.AncList[len(inputParams.AncList)-1]
	}
	state.Inputs[srcNodeId][lastAsyncAncestorId] = inputParams

	if inputNode.Async {
		runId := state.CurrentMaxRunId[dstNodeId]
		outputParams.AncList = append(
			outputParams.AncList,
			state.CurrentMaxRunId[dstNodeId],
		)
		state.CurrentMaxRunId[dstNodeId] += 1
		state.Outputs[srcNodeId][runId] = outputParams
		for _, desc := range state.Index.AsyncDescendants[srcNodeId] {
			if state.UnconsumedInputs[desc] == nil {
				state.UnconsumedInputs[desc] = make(map[int]struct{})
			}
			state.UnconsumedInputs[desc][runId] = struct{}{}
			if state.RemainingRuns[desc][inputRunId] == nil {
				state.RemainingRuns[desc][inputRunId] = make(map[int]struct{})
			}
			state.RemainingRuns[desc][inputRunId][runId] = struct{}{}
		}

		state.OutputToInputRunId[srcNodeId][runId] = inputRunId
		state.InputToOutputRunId[srcNodeId][inputRunId] = append(
			state.InputToOutputRunId[srcNodeId][inputRunId], runId,
		)
	} else {
		state.Outputs[srcNodeId][inputRunId] = outputParams
		state.OutputToInputRunId[srcNodeId][inputRunId] = inputRunId
		state.InputToOutputRunId[srcNodeId][inputRunId] = append(
			state.InputToOutputRunId[srcNodeId][inputRunId], inputRunId,
		)
	}
}

func (state *WorkflowExecutionState) markNodeRunComplete(
	nodeId int, ancList []int,
) error {
	inputIdOfNode := -1
	if len(ancList) > 0 {
		inputIdOfNode = ancList[len(ancList)-1]
	}

	inputIdOfLastAsyncAnc := -1
	if len(ancList) > 1 {
		inputIdOfLastAsyncAnc = ancList[len(ancList)-2]
	}

	if state.RemainingRuns[nodeId][inputIdOfLastAsyncAnc] == nil {
		return fmt.Errorf(
			"remainingRuns var missing node %d, runId %d",
			nodeId, inputIdOfLastAsyncAnc,
		)
	}

	delete(state.RemainingRuns[nodeId][inputIdOfLastAsyncAnc], inputIdOfNode)
	return nil
}

func (state *WorkflowExecutionState) formInputs(
	nodeId int, ancList []int,
) (NodeParams, error) {
	node, nodeExists := state.Workflow.Nodes[nodeId]
	if !nodeExists {
		return NodeParams{}, fmt.Errorf("non-existent node ID %d", nodeId)
	}

	ret := NodeParams{
		NodeId:  nodeId,
		NodeDef: node,
		AncList: ancList,
	}
	ret.Params = copyTypedParams(state.Index.BaseParams[nodeId])

	predRunIds, err := state.getPredRunIds(nodeId, ancList)
	if err != nil {
		return NodeParams{}, err
	}

	for _, link := range state.Index.InLinks[nodeId] {
		srcPval, sinkArgType, sinkChan, err := state.getLinkParam(
			link, node, nodeId, predRunIds,
		)

		if err != nil {
			return NodeParams{}, fmt.Errorf(
				"error forming input for node %d: %s",
				nodeId, err,
			)
		}

		err = ret.Params.AddParam(srcPval, sinkChan, sinkArgType)
		if err != nil {
			return NodeParams{}, err
		}
	}

	return ret, nil
}

func (state *WorkflowExecutionState) addCmdResults(
	inputs NodeParams,
	outputs []TypedParams,
) error {
	node, nodeExists := state.Workflow.Nodes[inputs.NodeId]
	if !nodeExists {
		return fmt.Errorf("node %d of inputs does not exist", inputs.NodeId)
	}

	if len(outputs) > 1 && !node.Async {
		return fmt.Errorf("multiple outputs given for non-async node")
	}

	inputAncList := inputs.AncList
	if len(inputAncList) != len(state.Index.AsyncAncestors[inputs.NodeId]) {
		return fmt.Errorf("inputs have invalid ancestor list")
	}

	inputRunId := getInputRunId(inputAncList)
	//outputRunIds := make([]int, 0, len(outputs))
	for _, output := range outputs {
		var outputParams NodeParams
		outputParams.NodeId = inputs.NodeId
		outputParams.NodeDef = state.Workflow.Nodes[inputs.NodeId]
		outputParams.Params = output
		outputParams.AncList = make([]int, len(inputAncList))
		copy(outputParams.AncList, inputAncList)

		state.addNodeRun(inputRunId, node, inputs, outputParams)
	}

	if err := state.markNodeRunComplete(inputs.NodeId, inputAncList); err != nil {
		return fmt.Errorf(
			"error marking node %d complete: %s", inputs.NodeId, err,
		)
	}
	return nil
}

// NodeID is async node. Run ID is the run ID of its input set,
// i.e. the run ID of the async ancestor of nodeId.
// TODO: Refactor this so to have a version which computes over
// all run IDs for a node.
func (state *WorkflowExecutionState) asyncBlockComplete(
	nodeId int, runId int,
) (bool, error) {
	node, nodeExists := state.Workflow.Nodes[nodeId]
	if !nodeExists {
		return false, fmt.Errorf("non-existent node %d", nodeId)
	}
	if !node.Async {
		return false, fmt.Errorf("node %d is not async", nodeId)
	}

	for _, descId := range state.Index.AsyncDescendants[nodeId] {
		if len(state.RemainingRuns[descId][runId]) > 0 {
			return false, nil
		}

		descNode := state.Workflow.Nodes[descId]
		if descNode.Async {
			for _, descRunId := range state.InputToOutputRunId[nodeId][runId] {
				descComplete, err := state.asyncBlockComplete(descId, descRunId)
				if err != nil {
					return false, err
				}
				if !descComplete {
					return false, nil
				}
			}
		}
	}

	return true, nil
}

func (state *WorkflowExecutionState) getEligibleSuccessors(
	nodeId int,
) (map[int][]NodeParams, error) {
	// ID -> ancestor list
	ret := make(map[int][]NodeParams)

    fmt.Printf("COMPLETED NODE %d\n", nodeId)
	for _, succ := range state.Index.Succs[nodeId] {
		succCanRun := true
		for _, predOfSucc := range state.Index.Preds[succ] {
			// Could we maybe filter this based on runId? I.e. Completion of
			// node ID with ancestor list will only trigger a successor if
			// other successors of pred have completed an iteration with same
			// ID of last async ancestor as nodeId?
			if len(state.Outputs[predOfSucc]) == 0 {
                fmt.Printf("\tsucc %d cannot run due to %d not having completed\n", succ, predOfSucc)
				succCanRun = false
				break
			}
		}

		if succCanRun {
			newAncestorLists, err := state.consumeAncestorLists(succ)
			if err != nil {
				return nil, fmt.Errorf(
					"error generating ancestor lists: %s", err,
				)
			}

			for _, ancList := range newAncestorLists {
				params, err := state.formInputs(succ, ancList)
				if err != nil {
					return nil, fmt.Errorf(
						"error forming inputs for node %d with ancestor list %v: %s",
						succ, ancList, err,
					)
				}
				ret[succ] = append(ret[succ], params)
			}
		}
	}

	return ret, nil
}
